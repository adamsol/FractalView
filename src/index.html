<html>
	<head>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js"></script>
		<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css">

		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.4/jstree.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.4/themes/default/style.min.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.8/goldenlayout.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.8/css/goldenlayout-base.css"/>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.8/css/goldenlayout-dark-theme.css"/>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.js"></script>

		<script src="utils.js"></script>

		<script src="views/scene.js"></script>

		<script type="x-shader/x-fragment" id="fragment_shader">
			precision highp float;

			uniform vec2 screenRes;
			uniform vec3 cameraPos;
			uniform vec3 cameraDir;

			const int MAX_STEPS = 60;
			const int NUM_ITERATIONS = 15;

			vec3 hsv2rgb(float x, float y, float z)
			{
				vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
				vec3 p = abs(fract(vec3(x) + K.xyz) * 6.0 - K.www);
				return z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), y);
			}
			vec3 hsv2rgb(vec3 c)
			{
				return hsv2rgb(c.x, c.y, c.z);
			}

			vec3 repeat(vec3 p, vec3 s)
			{
				return mod(p + s/2.0, s) - s/2.0;
			}

			vec3 rotateX(vec3 p, float a)
			{
				a = -a / 57.2957795130824;
				float c = cos(a), s = sin(a);
				return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c) * p;
			}
			vec3 rotateY(vec3 p, float a)
			{
				a = -a / 57.2957795130824;
				float c = cos(a), s = sin(a);
				return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c) * p;
			}
			vec3 rotateZ(vec3 p, float a)
			{
				a = -a / 57.2957795130824;
				float c = cos(a), s = sin(a);
				return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0) * p;
			}

			float sphere(vec3 p, float r)
			{
				return length(p) - r;
			}

			struct Distance
			{
				float value;
				vec3 color;
			};

			Distance Union(Distance a, Distance b)
			{
				if (a.value < b.value)
					return a;
				else
					return b;
			}
			Distance Intersection(Distance a, Distance b)
			{
				if (a.value > b.value)
					return a;
				else
					return b;
			}
			Distance Complement(Distance a)
			{
				return Distance(-a.value, a.color);
			}
			Distance Difference(Distance a, Distance b)
			{
				return Intersection(a, Complement(b));
			}

			Distance Mandelbulb(vec3 p)
			{
				const int n = NUM_ITERATIONS;
				vec3 z = vec3(0.0);
				vec3 d = vec3(1.0);
				float r = 0.0;
				float k = 6.0;
				float b = 10000.0;

				for (int i = 0; i < n; ++i)
				{
					d = k * pow(r, k-1.0) * d + 1.0;
					if (r > 0.0) {
						float phi = atan(z.z, z.x);
						phi *= k;
						float theta = acos(z.y/r);
						theta *= k;
						r = pow(r, k);
						z = vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta)) * r;
					}
					z += p;
					r = length(z);
					b = min(r, b);
					if (r >= 2.0)
						break;
				}
				return Distance(r * log(r) * 0.5 / length(d), hsv2rgb(vec3(b*1.3+0.3, 0.7, 0.9)));
			}

			Distance Juliabulb(vec3 p)
			{
				const int n = NUM_ITERATIONS;
				vec3 z = p;
				vec3 c = vec3(0.3, -0.9, -0.2);
				vec3 d = vec3(1.0);
				float r = 0.0;
				float k = 3.0;
				float b = 10000.0;

				for (int i = 0; i < n; ++i)
				{
					d = k * pow(r, k-1.0) * d + 1.0;
					if (r > 0.0) {
						float phi = atan(z.z, z.x);
						phi *= k;
						float theta = acos(z.y/r);
						theta *= k;
						r = pow(r, k);
						z = vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta)) * r;
					}
					z += c;
					r = length(z);
					b = min(r, b);
					if (r >= 2.0)
						break;
				}
				return Distance(r * log(r) * 0.5 / length(d), hsv2rgb(vec3(-b*1.3-0.5, 0.7, 0.9)));
			}

			Distance Sponge(vec3 p)
			{
				const int n = NUM_ITERATIONS;
				vec3 z = p;
				float scale = 3.0;
				float b = 10000.0;
				float t = 0.0;

				for (int i = 0; i < n; ++i)
				{
					z = abs(z);
					if (z.x - z.y < 0.0) { float x1 = z.y; z.y = z.x; z.x = x1; }
					if (z.x - z.z < 0.0) { float x1 = z.z; z.z = z.x; z.x = x1; }
					if (z.y - z.z < 0.0) { float y1 = z.z; z.z = z.y; z.y = y1; }

					z = rotateX(z, 25.0);
					z = rotateZ(z, 8.0);

					z.x = scale * z.x - (scale-1.0) * 1.0;
					z.y = scale * z.y - (scale-1.0) * 1.0;
					z.z = scale * z.z;
					if (z.z > (scale-1.0) * 0.5)
						z.z -= (scale-1.0) * 1.0;

					float m = dot(z, z);
					b = min(m, b);
					t = float(i+1);
					if (m >= 8.0)
						break;
				}

				return Distance((length(z)-2.0) * pow(scale, -t), hsv2rgb(-b*0.3-0.4, 0.6, 0.7));
			}

			Distance Tetrahedron(vec3 p)
			{
				const int n = NUM_ITERATIONS * 2;
				vec3 z = p;
				float scale = 1.7;
				float b = 10000.0;
				float t = 0.0;

				for (int i = 0; i < n; ++i)
				{
					z = rotateZ(z, -15.0);

					if (z.x + z.y < 0.0) { float x1 = -z.y; z.y = -z.x; z.x = x1; }
					if (z.x + z.z < 0.0) { float x1 = -z.z; z.z = -z.x; z.x = x1; }
					if (z.y + z.z < 0.0) { float y1 = -z.z; z.z = -z.y; z.y = y1; }

					z = rotateZ(z, 20.0);
					z = rotateX(z, 10.0);

					z.x = scale * z.x - (scale-1.0) * 1.0;
					z.y = scale * z.y - (scale-1.0) * 1.0;
					z.z = scale * z.z - (scale-1.0) * 1.0;

					float m = dot(z, z);
					b = min(m, b);
					t = float(i+1);
					if (m >= 8.0)
						break;
				}

				return Distance((length(z)-2.0) * pow(scale, -t), hsv2rgb(b*1.2 + 0.1, 0.6, 0.7));
			}

			Distance Octahedron(vec3 p)
			{
				const int n = NUM_ITERATIONS * 2;
				vec3 z = p;
				float scale = 2.0;
				float b = 10000.0;
				float t = 0.0;

				for (int i = 0; i < n; ++i)
				{
					if (z.x + z.y < 0.0) { float x1 = -z.y; z.y = -z.x; z.x = x1; }
					if (z.x + z.z < 0.0) { float x1 = -z.z; z.z = -z.x; z.x = x1; }
					if (z.x - z.y < 0.0) { float x1 = z.y; z.y = z.x; z.x = x1; }
					if (z.x - z.z < 0.0) { float x1 = z.z; z.z = z.x; z.x = x1; }

					z.x = scale * z.x - (scale-1.0) * 1.0;
					z.y = scale * z.y;
					z.z = scale * z.z;

					float m = dot(z, z);
					b = min(m, b);
					t = float(i+1);
					if (m >= 8.0)
						break;
				}

				return Distance((length(z)-2.0) * pow(scale, -t), hsv2rgb(-b*1.2+0.3, 0.6, 0.7));
			}

			Distance Scene(vec3 p)
			{
				return Sponge(repeat(p, vec3(5.0)));
			}

			struct Hit
			{
				bool is;
				vec3 pos, normal;
				vec3 color;
			};

			Hit raymarch(vec3 p, vec3 dir)
			{
				Distance dist = Scene(p);
				float eps = 0.0004 * dist.value;
				Hit hit;

				for (int i = 0; i < MAX_STEPS; ++i)
				{
					Distance dist = Scene(p);
					float d = dist.value;

					if (max(d, 0.0) <= eps) {
						hit.is = true;
						hit.pos = p;
						//hit.normal.x = scene(p + vec3(eps, 0.0, 0.0)).value - scene(p - vec3(eps, 0.0, 0.0)).value;
						//hit.normal.y = scene(p + vec3(0.0, eps, 0.0)).value - scene(p - vec3(0.0, eps, 0.0)).value;
						//hit.normal.z = scene(p + vec3(0.0, 0.0, eps)).value - scene(p - vec3(0.0, 0.0, eps)).value;
						//hit.normal = normalize(hit.normal);
						hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));
						return hit;
					}
					p += dir * d;
				}
				hit.is = false;
				hit.color = vec3(0.0);
				return hit;
			}

			void main(void)
			{
				vec2 p = (gl_FragCoord.xy*2.0 - screenRes) / min(screenRes.x, screenRes.y);

				vec3 cDir = cameraDir;
				vec3 cSide = normalize(cross(cDir, vec3(0.0, 1.0, 0.0)));
				vec3 cUp = normalize(cross(cSide, cDir));
				vec3 rayDir = normalize( cSide * p.x + cUp * p.y + cDir * 1.5);

				Hit hit = raymarch(cameraPos, rayDir);

				gl_FragColor = vec4(hit.color, 1.0);
			}

		</script>

		<script type="x-shader/x-vertex" id="vertex_shader">
			attribute vec3 position;

			void main(void)
			{
				gl_Position = vec4(position, 1.0);
			}
		</script>

		<script src="index.js"></script>
		<link rel="stylesheet" href="index.css"/>
	</head>

	<body>
	</body>
</html>
